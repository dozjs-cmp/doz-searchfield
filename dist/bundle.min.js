// [DozSearchfield]  Build version: 0.0.0  
 !function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("DozSearchfield",[],n):"object"==typeof exports?exports.DozSearchfield=n():e.DozSearchfield=n()}(window,function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./index.js")}({"./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _doz = __webpack_require__(/*! doz */ "./node_modules/doz/dist/doz.js");\n\nvar _doz2 = _interopRequireDefault(_doz);\n\nvar _lib = __webpack_require__(/*! ./lib */ "./lib/index.js");\n\nvar _lib2 = _interopRequireDefault(_lib);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// expose component to global scope\nif (typeof window !== \'undefined\') {\n    _doz2.default.component(\'doz-searchfield\', _lib2.default);\n}\n\nexports.default = _lib2.default;\n\n//# sourceURL=webpack://DozSearchfield/./index.js?')},"./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\n__webpack_require__(/*! ./style.css */ \"./lib/style.css\");\n\nexports.default = {\n\n    props: {\n        name: '',\n        value: '',\n        showButton: false,\n        buttonLabel: 'Search',\n        placeholder: 'Search here...',\n        buttonClass: '',\n        inputClass: '',\n        inputId: '',\n        showClearButton: true,\n        _showClear: false\n    },\n\n    template: function template() {\n        return '\\n            <input\\n                placeholder=\"' + this.props.placeholder + '\"\\n                class=\"' + this.props.inputClass + '\"\\n                type=\"text\"\\n                name=\"' + this.props.name + '\"\\n                value=\"' + this.props.value + '\"\\n                oninput=\"this.$onInput()\"\\n                onkeydown=\"this.$onKeyDown()\"\\n                d-bind=\"value\"\\n                id=\"' + this.props.inputId + '\"\\n            >\\n            <button \\n                class=\"' + this.props.buttonClass + '\" \\n                style=\"display: ' + (this.props._showClear ? 'inline' : 'none') + '\" \\n                onclick=\"this.$clear()\"\\n            >X</button>\\n            \\n            <button \\n                class=\"' + this.props.buttonClass + '\" \\n                style=\"display: ' + (this.props.showButton ? 'inline' : 'none') + '\" \\n                onclick=\"this.$search()\"\\n            >' + this.props.buttonLabel + '</button>\\n        ';\n    },\n    onCreate: function onCreate() {\n        this.props._showClear = this.$canShowClear();\n    },\n\n\n    $isSearching: false,\n\n    $canShowClear: function $canShowClear() {\n        return this.props.value.length > 0 && this.props.showClearButton;\n    },\n    $onInput: function $onInput() {\n        this.props._showClear = this.$canShowClear();\n        if (this.props.value.length === 0 && this.$isSearching) this.$clear();\n    },\n    $onKeyDown: function $onKeyDown(e) {\n        if (e.keyCode === 13) {\n            this.$search();\n        }\n    },\n    $search: function $search() {\n        this.emit('search', this.props.value);\n        this.$isSearching = true;\n    },\n    $clear: function $clear() {\n        this.props.value = '';\n        this.props._showClear = false;\n        this.emit('clear');\n        this.$isSearching = false;\n    }\n};\n\n//# sourceURL=webpack://DozSearchfield/./lib/index.js?")},"./lib/style.css":
/*!***********************!*\
  !*** ./lib/style.css ***!
  \***********************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./style.css */ "./node_modules/css-loader/index.js!./lib/style.css");\n\nif(typeof content === \'string\') content = [[module.i, content, \'\']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {"hmr":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack://DozSearchfield/./lib/style.css?')},"./node_modules/css-loader/index.js!./lib/style.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./lib/style.css ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);\n// imports\n\n\n// module\nexports.push([module.i, "", ""]);\n\n// exports\n\n\n//# sourceURL=webpack://DozSearchfield/./lib/style.css?./node_modules/css-loader')},"./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === "string") modules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === "number") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n\n//# sourceURL=webpack://DozSearchfield/./node_modules/css-loader/lib/css-base.js?')},"./node_modules/doz/dist/doz.js":
/*!**************************************!*\
  !*** ./node_modules/doz/dist/doz.js ***!
  \**************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// [DOZ]  Build version: 1.1.1  \n(function webpackUniversalModuleDefinition(root, factory) {\n    if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(typeof self !== 'undefined' ? self : undefined, function () {\n    return (/******/function (modules) {\n            // webpackBootstrap\n            /******/ // The module cache\n            /******/var installedModules = {};\n            /******/\n            /******/ // The require function\n            /******/function __webpack_require__(moduleId) {\n                /******/\n                /******/ // Check if module is in cache\n                /******/if (installedModules[moduleId]) {\n                    /******/return installedModules[moduleId].exports;\n                    /******/\n                }\n                /******/ // Create a new module (and put it into the cache)\n                /******/var module = installedModules[moduleId] = {\n                    /******/i: moduleId,\n                    /******/l: false,\n                    /******/exports: {}\n                    /******/ };\n                /******/\n                /******/ // Execute the module function\n                /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n                /******/\n                /******/ // Flag the module as loaded\n                /******/module.l = true;\n                /******/\n                /******/ // Return the exports of the module\n                /******/return module.exports;\n                /******/\n            }\n            /******/\n            /******/\n            /******/ // expose the modules object (__webpack_modules__)\n            /******/__webpack_require__.m = modules;\n            /******/\n            /******/ // expose the module cache\n            /******/__webpack_require__.c = installedModules;\n            /******/\n            /******/ // define getter function for harmony exports\n            /******/__webpack_require__.d = function (exports, name, getter) {\n                /******/if (!__webpack_require__.o(exports, name)) {\n                    /******/Object.defineProperty(exports, name, {\n                        /******/configurable: false,\n                        /******/enumerable: true,\n                        /******/get: getter\n                        /******/ });\n                    /******/\n                }\n                /******/\n            };\n            /******/\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/__webpack_require__.n = function (module) {\n                /******/var getter = module && module.__esModule ?\n                /******/function getDefault() {\n                    return module['default'];\n                } :\n                /******/function getModuleExports() {\n                    return module;\n                };\n                /******/__webpack_require__.d(getter, 'a', getter);\n                /******/return getter;\n                /******/\n            };\n            /******/\n            /******/ // Object.prototype.hasOwnProperty.call\n            /******/__webpack_require__.o = function (object, property) {\n                return Object.prototype.hasOwnProperty.call(object, property);\n            };\n            /******/\n            /******/ // __webpack_public_path__\n            /******/__webpack_require__.p = \"\";\n            /******/\n            /******/ // Load entry module and return exports\n            /******/return __webpack_require__(__webpack_require__.s = 12);\n            /******/\n        }(\n        /************************************************************************/\n        /******/[\n        /* 0 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            module.exports = {\n                ROOT: '__DOZ_GLOBAL_COMPONENTS__',\n                INSTANCE: '__DOZ_INSTANCE__',\n                CMP_INSTANCE: '__DOZ_CMP_INSTANCE__',\n                NS: {\n                    SVG: 'http://www.w3.org/2000/svg'\n                },\n                TAG: {\n                    ROOT: 'doz-root',\n                    EACH: 'doz-each-root',\n                    APP: 'doz-app',\n                    EMPTY: 'doz-empty',\n                    MOUNT: 'doz-mount',\n                    SUFFIX_ROOT: '-root'\n                },\n                REGEX: {\n                    IS_CUSTOM_TAG: /^\\w+-[\\w-]+$/,\n                    IS_CUSTOM_TAG_STRING: /<\\w+-[\\w-]+/,\n                    IS_BIND: /^d-bind$/,\n                    IS_REF: /^d-ref$/,\n                    IS_ALIAS: /^d:alias$/,\n                    IS_STORE: /^d:store$/,\n                    IS_COMPONENT_LISTENER: /^d:on-(\\w+)$/,\n                    IS_LISTENER: /^on/,\n                    IS_ID_SELECTOR: /^#[\\w-_:.]+$/,\n                    IS_PARENT_METHOD: /^parent.(.*)/,\n                    IS_STRING_QUOTED: /^\"\\w+\"/,\n                    GET_LISTENER: /^this.(.*)\\((.*)\\)/,\n                    TRIM_QUOTES: /^[\"'](.*)[\"']$/\n                },\n                ATTR: {\n                    // Attributes for HTMLElement\n                    BIND: 'd-bind',\n                    REF: 'd-ref',\n                    // Attributes for Components\n                    ALIAS: 'd:alias',\n                    STORE: 'd:store',\n                    LISTENER: 'd:on',\n                    ID: 'd:id',\n                    FORCE_UPDATE: 'forceupdate'\n                }\n            };\n\n            /***/\n        },\n        /* 1 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _require = __webpack_require__(0),\n                ROOT = _require.ROOT;\n\n            /**\r\n             * Get or create global collection\r\n             * @returns {{}|components|{InjectAsComment: boolean, InjectByTag: boolean}|{InjectAsComment, InjectByTag}|Array|*}\r\n             */\n\n            function getOrCreate() {\n                window[ROOT] = window[ROOT] || { components: {} };\n                return window[ROOT].components;\n            }\n\n            /**\r\n             * Register a component to global\r\n             * @param cmp\r\n             */\n            function register(cmp) {\n                var collection = getOrCreate();\n\n                var tag = cmp.tag.toUpperCase();\n\n                if (!collection.hasOwnProperty(tag)) {\n                    collection[tag] = cmp;\n                } else {\n                    throw new Error('Component ' + tag + ' already defined');\n                }\n            }\n\n            function removeAll() {\n                if (window[ROOT]) window[ROOT].components = {};\n            }\n\n            /**\r\n             * Get component from global\r\n             * @param tag\r\n             * @returns {*}\r\n             */\n            function get(tag) {\n                if (typeof tag !== 'string') throw new TypeError('tag must be a string');\n\n                tag = tag.toUpperCase();\n\n                var collection = getOrCreate();\n                return collection[tag];\n            }\n\n            module.exports = {\n                register: register,\n                get: get,\n                removeAll: removeAll\n            };\n\n            /***/\n        },\n        /* 2 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            } : function (obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            };\n\n            /**\r\n             * Copies deep missing properties to the target object\r\n             * @param targetObj {Object} target object\r\n             * @param defaultObj {Object} default object\r\n             * @param exclude {Array} exclude properties from copy\r\n             * @returns {*}\r\n             */\n\n            function extend(targetObj, defaultObj) {\n                var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n                for (var i in defaultObj) {\n                    /* istanbul ignore else  */\n                    if (defaultObj.hasOwnProperty(i) && exclude.indexOf(i) === -1) {\n                        if (!targetObj.hasOwnProperty(i) || typeof targetObj[i] === 'undefined') {\n                            targetObj[i] = defaultObj[i];\n                        } else if (_typeof(targetObj[i]) === 'object') {\n                            extend(targetObj[i], defaultObj[i]);\n                        }\n                    }\n                }\n                return targetObj;\n            }\n\n            /**\r\n             * Creates new target object and copies deep missing properties to the target object\r\n             * @param args[0] {Object} target object\r\n             * @param args[1] {Object} default object\r\n             * @param args[2] {Array} exclude properties from copy\r\n             * @returns {*}\r\n             */\n            function copy() {\n                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                }\n\n                args[0] = Object.assign({}, args[0]);\n                return extend.apply(this, args);\n            }\n\n            module.exports = extend;\n            module.exports.copy = copy;\n\n            /***/\n        },\n        /* 3 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            } : function (obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            };\n\n            var extend = __webpack_require__(2);\n\n            var _require = __webpack_require__(1),\n                register = _require.register;\n\n            var html = __webpack_require__(4);\n\n            var _require2 = __webpack_require__(0),\n                REGEX = _require2.REGEX,\n                TAG = _require2.TAG,\n                INSTANCE = _require2.INSTANCE,\n                CMP_INSTANCE = _require2.CMP_INSTANCE;\n\n            var collection = __webpack_require__(1);\n            var observer = __webpack_require__(16);\n            var hooks = __webpack_require__(6);\n\n            var _require3 = __webpack_require__(8),\n                transform = _require3.transform,\n                serializeProps = _require3.serializeProps;\n\n            var update = __webpack_require__(11).updateElement;\n            var store = __webpack_require__(22);\n            var ids = __webpack_require__(23);\n\n            var _require4 = __webpack_require__(24),\n                extract = _require4.extract;\n\n            var proxy = __webpack_require__(5);\n\n            function component(tag) {\n                var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n                if (typeof tag !== 'string') {\n                    throw new TypeError('Tag must be a string');\n                }\n\n                if (!REGEX.IS_CUSTOM_TAG.test(tag)) {\n                    throw new TypeError('Tag must contain a dash (-) like my-component');\n                }\n\n                var cmp = {};\n\n                cmp.tag = tag;\n\n                cmp.cfg = extend.copy(cfg, {\n                    autoCreateChildren: true,\n                    updateChildrenProps: true,\n                    props: {},\n                    template: function template() {\n                        return '';\n                    }\n                });\n\n                register(cmp);\n            }\n\n            function getInstances() {\n                var cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n                cfg.template = typeof cfg.template === 'string' ? html.create(cfg.template) : cfg.template;\n\n                cfg.root.appendChild(cfg.template);\n\n                var component = null;\n                var parentElement = void 0;\n                var trash = [];\n\n                function walk(child) {\n                    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n                    while (child) {\n\n                        var cmpName = child.nodeName.toLowerCase();\n                        var localComponents = {};\n\n                        if (parent.cmp && parent.cmp._components) {\n                            localComponents = parent.cmp._components;\n                        }\n\n                        var cmp = cfg.autoCmp || localComponents[cmpName] || cfg.app._components[cmpName] || collection.get(child.nodeName);\n\n                        if (cmp) {\n\n                            if (parent.cmp) {\n                                var rawChild = child.outerHTML;\n                                parent.cmp.rawChildren.push(rawChild);\n                            }\n\n                            if (parent.cmp && parent.cmp.autoCreateChildren === false) {\n                                trash.push(child);\n                                child = child.nextSibling;\n                                continue;\n                            }\n\n                            var props = serializeProps(child);\n                            var dProps = extract(props);\n\n                            var newElement = createInstance(cmp, {\n                                root: child,\n                                app: cfg.app,\n                                props: props,\n                                dProps: dProps,\n                                parentCmp: parent.cmp\n                            });\n\n                            if (!newElement) {\n                                child = child.nextSibling;\n                                continue;\n                            }\n\n                            if (hooks.callBeforeMount(newElement) !== false) {\n                                newElement.render(true);\n\n                                if (!component) {\n                                    component = newElement;\n                                }\n\n                                newElement._rootElement[CMP_INSTANCE] = newElement;\n\n                                child.insertBefore(newElement._rootElement, child.firstChild);\n                                hooks.callRender(newElement);\n                                hooks.callMount(newElement);\n                            }\n\n                            parentElement = newElement;\n\n                            if (parent.cmp) {\n                                var n = Object.keys(parent.cmp.children).length;\n                                parent.cmp.children[newElement.alias ? newElement.alias : n++] = newElement;\n                            }\n\n                            cfg.autoCmp = null;\n                        }\n\n                        if (child.hasChildNodes()) {\n                            walk(child.firstChild, { cmp: parentElement });\n                        }\n\n                        child = child.nextSibling;\n                    }\n                }\n\n                walk(cfg.template);\n\n                trash.forEach(function (child) {\n                    return child.remove();\n                });\n\n                return component;\n            }\n\n            function createInstance(cmp, cfg) {\n\n                var props = extend.copy(cfg.props, typeof cmp.cfg.props === 'function' ? cmp.cfg.props() : cmp.cfg.props);\n\n                var instance = Object.defineProperties({}, {\n                    _isCreated: {\n                        value: false,\n                        writable: true\n                    },\n                    _prevTpl: {\n                        value: null,\n                        writable: true\n                    },\n                    _prev: {\n                        value: null,\n                        writable: true\n                    },\n                    _prevProps: {\n                        value: null,\n                        writable: true\n                    },\n                    _rootElement: {\n                        value: null,\n                        writable: true\n                    },\n                    _boundElements: {\n                        value: {},\n                        writable: true\n                    },\n                    _callback: {\n                        value: cfg.dProps['callback'],\n                        writable: true\n                    },\n                    _cache: {\n                        value: new Map()\n                    },\n                    _loops: {\n                        value: {},\n                        writable: true\n                    },\n                    _components: {\n                        value: {},\n                        writable: true\n                    },\n                    _publicProps: {\n                        value: Object.assign({}, cfg.props)\n                    },\n                    _processing: {\n                        value: [],\n                        writable: true\n                    },\n                    _dynamicChildren: {\n                        value: [],\n                        writable: true\n                    },\n                    _unmounted: {\n                        value: false,\n                        writable: true\n                    },\n                    _unmountedParentNode: {\n                        value: null,\n                        writable: true\n                    },\n                    beginSafeRender: {\n                        value: function value() {\n                            proxy.beginRender(this.props);\n                        },\n                        enumerable: true\n                    },\n                    endSafeRender: {\n                        value: function value() {\n                            proxy.endRender(this.props);\n                        },\n                        enumerable: true\n                    },\n                    app: {\n                        value: cfg.app,\n                        enumerable: true\n                    },\n                    parent: {\n                        value: cfg.parentCmp,\n                        enumerable: true\n                    },\n                    ref: {\n                        value: {},\n                        writable: true,\n                        enumerable: true\n                    },\n                    children: {\n                        value: {},\n                        writable: true,\n                        enumerable: true\n                    },\n                    rawChildren: {\n                        value: [],\n                        writable: true,\n                        enumerable: true\n                    },\n                    tag: {\n                        value: cmp.tag,\n                        enumerable: true\n                    },\n                    emit: {\n                        value: function value(name) {\n                            if (this._callback && this._callback[name] !== undefined && this.parent[this._callback[name]] !== undefined && typeof this.parent[this._callback[name]] === 'function') {\n                                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                                    args[_key - 1] = arguments[_key];\n                                }\n\n                                this.parent[this._callback[name]].apply(this.parent, args);\n                            }\n                        },\n                        enumerable: true\n                    },\n                    each: {\n                        value: function value(obj, func) {\n                            var safe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                            var res = void 0;\n                            if (Array.isArray(obj)) {\n                                if (safe) this.beginSafeRender();\n                                res = obj.map(func).map(function (stringEl) {\n                                    if (typeof stringEl === 'string') {\n\n                                        return stringEl.trim();\n                                    }\n                                }).join('');\n                                if (safe) this.endSafeRender();\n                            }\n                            return res;\n                        },\n                        enumerable: true\n                    },\n                    getStore: {\n                        value: function value(storeName) {\n                            return this.app.getStore(storeName);\n                        },\n                        enumerable: true\n                    },\n                    getComponentById: {\n                        value: function value(id) {\n                            return this.app.getComponentById(id);\n                        },\n                        enumerable: true\n                    },\n                    action: {\n                        value: cfg.app.action,\n                        enumerable: true\n                    },\n                    render: {\n                        value: function value(initial) {\n                            this.beginSafeRender();\n                            var template = this.template().trim();\n                            this.endSafeRender();\n\n                            var tpl = html.create(template, TAG.ROOT);\n                            var next = transform(tpl);\n\n                            var rootElement = update(cfg.root, next, this._prev, 0, this, initial);\n\n                            drawDynamic(this);\n\n                            if (!this._rootElement && rootElement) {\n                                this._rootElement = rootElement;\n                            }\n\n                            this._prev = next;\n                        },\n                        enumerable: true\n                    },\n                    mount: {\n                        value: function value(template) {\n                            var _this = this;\n\n                            var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n                            if (this._unmounted) {\n                                if (hooks.callBeforeMount(this) === false) return this;\n\n                                this._unmountedParentNode.appendChild(this._rootElement.parentNode);\n                                this._unmounted = false;\n                                this._unmountedParentNode = null;\n\n                                hooks.callMount(this);\n\n                                Object.keys(this.children).forEach(function (child) {\n                                    _this.children[child].mount();\n                                });\n\n                                return this;\n                            } else if (template) {\n                                if (this._rootElement.nodeType !== 1) {\n                                    var newElement = document.createElement(this.tag + TAG.SUFFIX_ROOT);\n                                    this._rootElement.parentNode.replaceChild(newElement, this._rootElement);\n                                    this._rootElement = newElement;\n                                    this._rootElement[CMP_INSTANCE] = this;\n                                }\n\n                                var root = this._rootElement;\n\n                                if (typeof cfg.selector === 'string') root = root.querySelector(cfg.selector);else if (cfg.selector instanceof HTMLElement) root = cfg.selector;\n\n                                this._unmounted = false;\n                                this._unmountedParentNode = null;\n\n                                return this.app.mount(template, root, this);\n                            }\n                        },\n                        enumerable: true\n                    },\n                    unmount: {\n                        value: function value() {\n                            var onlyInstance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n                            var _this2 = this;\n\n                            var byDestroy = arguments[1];\n                            var silently = arguments[2];\n\n                            if (!onlyInstance && (Boolean(this._unmountedParentNode) || !this._rootElement || !this._rootElement.parentNode || !this._rootElement.parentNode.parentNode)) {\n                                return;\n                            }\n\n                            if (hooks.callBeforeUnmount(this) === false) return false;\n\n                            this._unmountedParentNode = this._rootElement.parentNode.parentNode;\n\n                            if (!onlyInstance) {\n                                this._rootElement.parentNode.parentNode.removeChild(this._rootElement.parentNode);\n                            } else this._rootElement.parentNode.innerHTML = '';\n\n                            this._unmounted = !byDestroy;\n\n                            if (!silently) hooks.callUnmount(this);\n\n                            Object.keys(this.children).forEach(function (child) {\n                                _this2.children[child].unmount(onlyInstance, byDestroy, silently);\n                            });\n\n                            return this;\n                        },\n                        enumerable: true\n                    },\n                    destroy: {\n                        value: function value(onlyInstance) {\n                            var _this3 = this;\n\n                            if (this.unmount(onlyInstance, true) === false) return;\n\n                            if (!onlyInstance && (!this._rootElement || hooks.callBeforeDestroy(this) === false || !this._rootElement.parentNode)) {\n                                return;\n                            }\n\n                            Object.keys(this.children).forEach(function (child) {\n                                _this3.children[child].destroy();\n                            });\n\n                            hooks.callDestroy(this);\n                        },\n                        enumerable: true\n                    }\n                });\n\n                // Assign cfg to instance\n                extendInstance(instance, cmp.cfg, cfg.dProps);\n\n                var beforeCreate = hooks.callBeforeCreate(instance);\n                if (beforeCreate === false) return undefined;\n\n                // Create observer to props\n                observer.create(instance, props);\n                // Create shared store\n                store.create(instance);\n                // Create ID\n                ids.create(instance);\n                // Add callback to ready queue\n                queueReadyCB(instance);\n                // Call create\n                hooks.callCreate(instance);\n                // Now instance is created\n                instance._isCreated = true;\n\n                return instance;\n            }\n\n            function extendInstance(instance, cfg, dProps) {\n                Object.assign(instance, cfg, dProps);\n\n                // Add local components\n                if (Array.isArray(cfg.components)) {\n                    cfg.components.forEach(function (cmp) {\n                        if ((typeof cmp === 'undefined' ? 'undefined' : _typeof(cmp)) === 'object' && typeof cmp.tag === 'string' && _typeof(cmp.cfg) === 'object') {\n                            instance._components[cmp.tag] = cmp;\n                        }\n                    });\n                    delete instance.components;\n                } else if (_typeof(cfg.components) === 'object') {\n                    Object.keys(cfg.components).forEach(function (objName) {\n                        instance._components[objName] = {\n                            tag: objName,\n                            cfg: cfg.components[objName]\n                        };\n                    });\n                    delete instance.components;\n                }\n            }\n\n            function queueReadyCB(instance) {\n                if (typeof instance.onAppReady === 'function') {\n                    instance.onAppReady._instance = instance;\n                    instance.app._onAppReadyCB.push(instance.onAppReady);\n                }\n            }\n\n            function clearDynamic(instance) {\n                var index = instance._dynamicChildren.length - 1;\n\n                while (index >= 0) {\n                    var item = instance._dynamicChildren[index];\n\n                    if (!document.body.contains(item) && item[INSTANCE]) {\n                        item[INSTANCE].destroy(true);\n                        instance._dynamicChildren.splice(index, 1);\n                    }\n                    index -= 1;\n                }\n            }\n\n            function drawDynamic(instance) {\n                clearDynamic(instance);\n\n                var index = instance._processing.length - 1;\n\n                while (index >= 0) {\n                    var item = instance._processing[index];\n                    var root = item.node.parentNode;\n\n                    if (item.node[INSTANCE]) {\n                        item.node[INSTANCE].destroy(true);\n                    }\n\n                    var dynamicInstance = getInstances({ root: root, template: item.node.outerHTML, app: instance.app });\n\n                    if (dynamicInstance) {\n                        instance._dynamicChildren.push(dynamicInstance._rootElement.parentNode);\n\n                        root.replaceChild(dynamicInstance._rootElement.parentNode, item.node);\n                        dynamicInstance._rootElement.parentNode[INSTANCE] = dynamicInstance;\n                        instance._processing.splice(index, 1);\n                    }\n                    index -= 1;\n                }\n            }\n\n            module.exports = {\n                component: component,\n                getInstances: getInstances\n            };\n\n            /***/\n        },\n        /* 4 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var regexN = /\\n/g;\n            var regexS = /\\s+/g;\n            var replace = ' ';\n\n            var html = {\n                /**\r\n                 * Create DOM element\r\n                 * @param str html string\r\n                 * @param wrapper tag string\r\n                 * @returns {Element | Node | null}\r\n                 */\n                create: function create(str, wrapper) {\n                    var element = void 0;\n                    str = str.replace(regexN, replace);\n                    str = str.replace(regexS, replace);\n\n                    var template = document.createElement('div');\n                    template.innerHTML = str;\n\n                    if (template.childNodes.length > 1) {\n                        element = document.createElement(wrapper);\n                        //console.log('TEMPLATE',template.innerHTML);\n                        element.innerHTML = template.innerHTML;\n                    } else {\n                        //console.log('TEMPLATE',template.innerHTML);\n                        element = template.firstChild || document.createTextNode('');\n                    }\n\n                    if (!this.isValidNode(element)) throw new Error('Element not valid');\n                    return element;\n                },\n\n                /**\r\n                 * Check if is a valid Node\r\n                 * @param {*} el\r\n                 * @returns {Boolean}\r\n                 */\n                isValidNode: function isValidNode(el) {\n                    return el && 'nodeType' in el;\n                },\n\n                getAllNodes: function getAllNodes(el) {\n\n                    var nodes = [];\n\n                    function scanner(n) {\n                        while (n) {\n                            nodes.push(n);\n                            if (n.hasChildNodes()) {\n                                scanner(n.firstChild);\n                            }\n                            n = n.nextSibling;\n                        }\n                    }\n\n                    scanner(el);\n\n                    return nodes;\n                }\n            };\n\n            module.exports = html;\n\n            /***/\n        },\n        /* 5 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            } : function (obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            };\n\n            /*\r\n             * \tOriginally was Observable Slim\r\n             *\tVersion 0.0.4\r\n             * \thttps://github.com/elliotnb/observable-slim\r\n             *\r\n             * \tLicensed under the MIT license:\r\n             * \thttp://www.opensource.org/licenses/MIT\r\n             *\r\n             *\tObservable Slim is a singleton that allows you to observe changes made to an object and any nested\r\n             *\tchildren of that object. It is intended to assist with one-way data binding, that is, in MVC parlance,\r\n             *\treflecting changes in the model to the app. Observable Slim aspires to be as lightweight and easily\r\n             *\tunderstood as possible. Minifies down to roughly 3000 characters.\r\n             */\n\n            function sanitize(str) {\n                return typeof str === 'string' ? str.replace(/&(?!\\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;') : str;\n            }\n\n            /**\r\n             * ObservableSlim\r\n             * @type {{create, observe, pause, resume, remove, beforeChange}}\r\n             */\n            var ObservableSlim = function () {\n                // An array that stores all of the observables created through the public create() method below.\n                var observables = [];\n                // An array of all the objects that we have assigned Proxies to\n                var targets = [];\n\n                // An array of arrays containing the Proxies created for each target object. targetsProxy is index-matched with\n                // 'targets' -- together, the pair offer a Hash table where the key is not a string nor number, but the actual target object\n                var targetsProxy = [];\n\n                // this variable tracks duplicate proxies assigned to the same target.\n                // the 'set' handler below will trigger the same change on all other Proxies tracking the same target.\n                // however, in order to avoid an infinite loop of Proxies triggering and re-triggering one another, we use dupProxy\n                // to track that a given Proxy was modified from the 'set' handler\n                var dupProxy = null;\n\n                var _getProperty = function _getProperty(obj, path) {\n                    return path.split('.').reduce(function (prev, curr) {\n                        return prev ? prev[curr] : undefined;\n                    }, obj || self);\n                };\n\n                /**\r\n                 * _create\r\n                 * @description Private internal function that is invoked to create a new ES6 Proxy whose changes we can observe through the Observerable.observe() method.\r\n                 * @param target {Object} required, plain JavaScript object that we want to observe for changes.\r\n                 * @param domDelay {Boolean} batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n                 * @param originalObservable {Object} the original observable created by the user, exists for recursion purposes, allows one observable to observe change on any nested/child objects.\r\n                 * @param originalPath {String} the path of the property in relation to the target on the original observable, exists for recursion purposes, allows one observable to observe change on any nested/child objects.\r\n                 * @returns {Object}\r\n                 * @private\r\n                 */\n                var _create = function _create(target, domDelay, originalObservable, originalPath) {\n\n                    var observable = originalObservable || null;\n                    var path = originalPath || '';\n\n                    var changes = [];\n\n                    var _getPath = function _getPath(target, property) {\n                        if (target instanceof Array) {\n                            return path !== '' ? path : property;\n                        } else {\n                            return path !== '' ? path + '.' + property : property;\n                        }\n                    };\n\n                    var _notifyObservers = function _notifyObservers(numChanges) {\n\n                        // if the observable is paused, then we don't want to execute any of the observer functions\n                        if (observable.paused === true) return;\n\n                        // execute observer functions on a 10ms settimeout, this prevents the observer functions from being executed\n                        // separately on every change -- this is necessary because the observer functions will often trigger UI updates\n                        if (domDelay === true) {\n                            setTimeout(function () {\n                                if (numChanges === changes.length) {\n                                    // invoke any functions that are observing changes\n                                    for (var i = 0; i < observable.observers.length; i++) {\n                                        observable.observers[i](changes);\n                                    }changes = [];\n                                }\n                            }, 10);\n                        } else {\n                            // invoke any functions that are observing changes\n                            for (var i = 0; i < observable.observers.length; i++) {\n                                observable.observers[i](changes);\n                            }changes = [];\n                        }\n                    };\n\n                    var handler = {\n                        get: function get(target, property) {\n\n                            // implement a simple check for whether or not the object is a proxy, this helps the .create() method avoid\n                            // creating Proxies of Proxies.\n                            if (property === '__getTarget') {\n                                return target;\n                            } else if (property === '__isProxy') {\n                                return true;\n                                // from the perspective of a given observable on a parent object, return the parent object of the given nested object\n                            } else if (property === '__getParent') {\n                                return function (i) {\n                                    if (typeof i === 'undefined') i = 1;\n                                    var parentPath = _getPath(target, '__getParent').split('.');\n                                    parentPath.splice(-(i + 1), i + 1);\n                                    return _getProperty(observable.parentProxy, parentPath.join('.'));\n                                };\n                            }\n\n                            // for performance improvements, we assign this to a variable so we do not have to lookup the property value again\n                            var targetProp = target[property];\n\n                            // if we are traversing into a new object, then we want to record path to that object and return a new observable.\n                            // recursively returning a new observable allows us a single Observable.observe() to monitor all changes on\n                            // the target object and any objects nested within.\n                            if (targetProp instanceof Object && targetProp !== null && target.hasOwnProperty(property)) {\n\n                                // if we've found a proxy nested on the object, then we want to retrieve the original object behind that proxy\n                                if (targetProp.__isProxy === true) targetProp = targetProp.__getTarget;\n\n                                // if we've previously setup a proxy on this target, then...\n                                //let a = observable.targets.indexOf(targetProp);\n                                var a = -1;\n                                var observableTargets = observable.targets;\n                                for (var i = 0, l = observableTargets.length; i < l; i++) {\n                                    if (targetProp === observableTargets[i]) {\n                                        a = i;\n                                        break;\n                                    }\n                                }\n                                if (a > -1) return observable.proxies[a];\n\n                                // if we're arrived here, then that means there is no proxy for the object the user just accessed, so we\n                                // have to create a new proxy for it\n                                var newPath = path !== '' ? path + '.' + property : property;\n\n                                return _create(targetProp, domDelay, observable, newPath);\n                            } else {\n                                return observable.renderMode ? sanitize(targetProp) : targetProp;\n                            }\n                        },\n                        deleteProperty: function deleteProperty(target, property) {\n\n                            // was this change an original change or was it a change that was re-triggered below\n                            var originalChange = true;\n                            if (dupProxy === proxy) {\n                                originalChange = false;\n                                dupProxy = null;\n                            }\n\n                            // in order to report what the previous value was, we must make a copy of it before it is deleted\n                            var previousValue = Object.assign({}, target);\n\n                            // get the path of the property being deleted\n                            var currentPath = _getPath(target, property);\n\n                            // record the deletion that just took place\n                            changes.push({\n                                type: 'delete',\n                                target: target,\n                                property: property,\n                                newValue: null,\n                                previousValue: previousValue[property],\n                                currentPath: currentPath,\n                                proxy: proxy\n                            });\n\n                            if (typeof observable.beforeChange === 'function' && observable.checkBeforeChange !== currentPath) {\n                                observable.checkBeforeChange = currentPath;\n                                var res = observable.beforeChange(changes);\n                                if (res === false) {\n                                    observable.checkBeforeChange = '';\n                                    return false;\n                                }\n                            }\n\n                            observable.checkBeforeChange = '';\n\n                            if (originalChange === true) {\n                                var a = void 0,\n                                    l = void 0;\n                                for (a = 0, l = targets.length; a < l; a++) {\n                                    if (target === targets[a]) break;\n                                } // loop over each proxy and see if the target for this change has any other proxies\n                                var currentTargetProxy = targetsProxy[a];\n\n                                var b = currentTargetProxy.length;\n                                while (b--) {\n                                    // if the same target has a different proxy\n                                    if (currentTargetProxy[b].proxy !== proxy) {\n                                        // !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\n                                        // prevent a change on dupProxy from re-triggering the same change on other proxies)\n                                        dupProxy = currentTargetProxy[b].proxy;\n\n                                        // make the same delete on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\n                                        // on any other proxies so that the previousValue can show up correct for the other proxies\n                                        delete currentTargetProxy[b].proxy[property];\n                                    }\n                                }\n\n                                // perform the delete that we've trapped\n                                delete target[property];\n                            }\n\n                            _notifyObservers(changes.length);\n\n                            return true;\n                        },\n                        set: function set(target, property, value, receiver) {\n\n                            // was this change an original change or was it a change that was re-triggered below\n                            var originalChange = true;\n                            if (dupProxy === proxy) {\n                                originalChange = false;\n                                dupProxy = null;\n                            }\n\n                            // improve performance by saving direct references to the property\n                            var targetProp = target[property];\n\n                            // only record a change if the new value differs from the old one OR if this proxy was not the original proxy to receive the change\n                            if (targetProp !== value || originalChange === false) {\n\n                                var typeOfTargetProp = typeof targetProp === 'undefined' ? 'undefined' : _typeof(targetProp);\n\n                                // get the path of the object property being modified\n                                var currentPath = _getPath(target, property);\n\n                                // determine if we're adding something new or modifying somethat that already existed\n                                var type = 'update';\n                                if (typeOfTargetProp === 'undefined') type = 'add';\n\n                                // store the change that just occurred. it is important that we store the change before invoking the other proxies so that the previousValue is correct\n                                changes.push({\n                                    type: type,\n                                    target: target,\n                                    property: property,\n                                    newValue: value,\n                                    previousValue: receiver[property],\n                                    currentPath: currentPath,\n                                    proxy: proxy\n                                });\n\n                                if (typeof observable.beforeChange === 'function' && observable.checkBeforeChange !== currentPath) {\n                                    observable.checkBeforeChange = currentPath;\n                                    var res = observable.beforeChange(changes);\n                                    if (res === false) {\n                                        observable.checkBeforeChange = '';\n                                        return false;\n                                    }\n                                }\n\n                                observable.checkBeforeChange = '';\n\n                                // !!IMPORTANT!! if this proxy was the first proxy to receive the change, then we need to go check and see\n                                // if there are other proxies for the same project. if there are, then we will modify those proxies as well so the other\n                                // observers can be modified of the change that has occurred.\n                                if (originalChange === true) {\n\n                                    var a = void 0,\n                                        l = void 0;\n                                    for (a = 0, l = targets.length; a < l; a++) {\n                                        if (target === targets[a]) break;\n                                    } // loop over each proxy and see if the target for this change has any other proxies\n                                    var currentTargetProxy = targetsProxy[a];\n                                    if (currentTargetProxy) for (var b = 0, _l = currentTargetProxy.length; b < _l; b++) {\n                                        // if the same target has a different proxy\n                                        if (currentTargetProxy[b].proxy !== proxy) {\n\n                                            // !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\n                                            // prevent a change on dupProxy from re-triggering the same change on other proxies)\n                                            dupProxy = currentTargetProxy[b].proxy;\n\n                                            // invoke the same change on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\n                                            // on any other proxies so that the previousValue can show up correct for the other proxies\n                                            currentTargetProxy[b].proxy[property] = value;\n                                        }\n                                    }\n\n                                    // if the property being overwritten is an object, then that means this observable\n                                    // will need to stop monitoring this object and any nested objects underneath the overwritten object else they'll become\n                                    // orphaned and grow memory usage. we excute this on a setTimeout so that the clean-up process does not block\n                                    // the UI rendering -- there's no need to execute the clean up immediately\n                                    setTimeout(function () {\n\n                                        if (typeOfTargetProp === 'object' && targetProp !== null) {\n\n                                            // check if the to-be-overwritten target property still exists on the target object\n                                            // if it does still exist on the object, then we don't want to stop observing it. this resolves\n                                            // an issue where array .sort() triggers objects to be overwritten, but instead of being overwritten\n                                            // and discarded, they are shuffled to a new position in the array\n                                            var keys = Object.keys(target);\n                                            for (var i = 0, _l2 = keys.length; i < _l2; i++) {\n                                                if (target[keys[i]] === targetProp) {\n                                                    //console.log('target still exists');\n                                                    return;\n                                                }\n                                            }\n\n                                            // loop over each property and recursively invoke the `iterate` function for any\n                                            // objects nested on targetProp\n                                            (function iterate(obj) {\n\n                                                var keys = Object.keys(obj);\n                                                for (var _i = 0, _l3 = keys.length; _i < _l3; _i++) {\n                                                    var objProp = obj[keys[_i]];\n                                                    if (objProp instanceof Object && objProp !== null) iterate(objProp);\n                                                }\n\n                                                // if there are any existing target objects (objects that we're already observing)...\n                                                //let c = targets.indexOf(obj);\n                                                var c = -1;\n                                                for (var _i2 = 0, _l4 = targets.length; _i2 < _l4; _i2++) {\n                                                    if (obj === targets[_i2]) {\n                                                        c = _i2;\n                                                        break;\n                                                    }\n                                                }\n                                                if (c > -1) {\n\n                                                    // ...then we want to determine if the observables for that object match our current observable\n                                                    var _currentTargetProxy = targetsProxy[c];\n                                                    var d = _currentTargetProxy.length;\n\n                                                    while (d--) {\n                                                        // if we do have an observable monitoring the object thats about to be overwritten\n                                                        // then we can remove that observable from the target object\n                                                        if (observable === _currentTargetProxy[d].observable) {\n                                                            _currentTargetProxy.splice(d, 1);\n                                                            break;\n                                                        }\n                                                    }\n\n                                                    // if there are no more observables assigned to the target object, then we can remove\n                                                    // the target object altogether. this is necessary to prevent growing memory consumption particularly with large data sets\n                                                    if (_currentTargetProxy.length === 0) {\n                                                        targetsProxy.splice(c, 1);\n                                                        targets.splice(c, 1);\n                                                    }\n                                                }\n                                            })(targetProp);\n                                        }\n                                    }, 10000);\n\n                                    // because the value actually differs than the previous value\n                                    // we need to store the new value on the original target object\n                                    target[property] = value;\n\n                                    // TO DO: the next block of code resolves test case #24, but it results in poor IE11 performance. Find a solution.\n\n                                    // if the value we've just set is an object, then we'll need to iterate over it in order to initialize the\n                                    // observers/proxies on all nested children of the object\n                                    if (value instanceof Object && value !== null) {\n                                        (function iterate(proxy) {\n                                            var target = proxy.__getTarget;\n                                            var keys = Object.keys(target);\n                                            for (var i = 0, _l5 = keys.length; i < _l5; i++) {\n                                                var _property = keys[i];\n                                                if (target[_property] instanceof Object && target[_property] !== null) iterate(proxy[_property]);\n                                            }\n                                        })(proxy[property]);\n                                    }\n                                }\n                                // notify the observer functions that the target has been modified\n                                _notifyObservers(changes.length);\n                            }\n                            return true;\n                        }\n                    };\n\n                    // create the proxy that we'll use to observe any changes\n                    var proxy = new Proxy(target, handler);\n\n                    // we don't want to create a new observable if this function was invoked recursively\n                    if (observable === null) {\n                        observable = {\n                            parentTarget: target,\n                            domDelay: domDelay,\n                            parentProxy: proxy,\n                            observers: [],\n                            targets: [target],\n                            proxies: [proxy],\n                            paused: false,\n                            path: path\n                        };\n                        observables.push(observable);\n                    } else {\n                        observable.targets.push(target);\n                        observable.proxies.push(proxy);\n                    }\n\n                    // store the proxy we've created so it isn't re-created unnecessary via get handler\n                    var proxyItem = { target: target, proxy: proxy, observable: observable };\n\n                    //let targetPosition = targets.indexOf(target);\n                    var targetPosition = -1;\n                    for (var i = 0, l = targets.length; i < l; i++) {\n                        if (target === targets[i]) {\n                            targetPosition = i;\n                            break;\n                        }\n                    }\n\n                    // if we have already created a Proxy for this target object then we add it to the corresponding array\n                    // on targetsProxy (targets and targetsProxy work together as a Hash table indexed by the actual target object).\n                    if (targetPosition > -1) {\n                        targetsProxy[targetPosition].push(proxyItem);\n                        // else this is a target object that we have not yet created a Proxy for, so we must add it to targets,\n                        // and push a new array on to targetsProxy containing the new Proxy\n                    } else {\n                        targets.push(target);\n                        targetsProxy.push([proxyItem]);\n                        targetPosition = targets.length - 1;\n                    }\n\n                    return proxy;\n                };\n\n                return {\n                    /**\r\n                     * Create\r\n                     * @description Public method that is invoked to create a new ES6 Proxy whose changes we can observe through the Observerable.observe() method.\r\n                     * @param target {Object} required, plain JavaScript object that we want to observe for changes.\r\n                     * @param domDelay {Boolean} if true, then batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n                     * @param observer {Function} optional, will be invoked when a change is made to the proxy.\r\n                     * @returns {Object}\r\n                     */\n                    create: function create(target, domDelay, observer) {\n\n                        // test if the target is a Proxy, if it is then we need to retrieve the original object behind the Proxy.\n                        // we do not allow creating proxies of proxies because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\n                        if (target.__isProxy === true) {\n                            target = target.__getTarget;\n                            //if it is, then we should throw an error. we do not allow creating proxies of proxies\n                            // because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\n                            //throw new Error('ObservableSlim.create() cannot create a Proxy for a target object that is also a Proxy.');\n                        }\n\n                        // fire off the _create() method -- it will create a new observable and proxy and return the proxy\n                        var proxy = _create(target, domDelay);\n\n                        // assign the observer function\n                        if (typeof observer === 'function') this.observe(proxy, observer);\n\n                        // recursively loop over all nested objects on the proxy we've just created\n                        // this will allow the top observable to observe any changes that occur on a nested object\n                        (function iterate(proxy) {\n                            var target = proxy.__getTarget;\n                            var keys = Object.keys(target);\n                            for (var i = 0, l = keys.length; i < l; i++) {\n                                var property = keys[i];\n                                if (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\n                            }\n                        })(proxy);\n\n                        return proxy;\n                    },\n\n                    /**\r\n                     * observe\r\n                     * @description This method is used to add a new observer function to an existing proxy.\r\n                     * @param proxy {Proxy} the ES6 Proxy returned by the create() method. We want to observe changes made to this object.\r\n                     * @param observer {Function} this function will be invoked when a change is made to the observable (not to be confused with the observer defined in the create() method).\r\n                     */\n                    observe: function observe(proxy, observer) {\n                        // loop over all the observables created by the _create() function\n                        var i = observables.length;\n                        while (i--) {\n                            if (observables[i].parentProxy === proxy) {\n                                observables[i].observers.push(observer);\n                                break;\n                            }\n                        }\n                    },\n\n                    /**\r\n                     * Pause\r\n                     * @param proxy {Proxy} the ES6 Proxy returned by the create() method\r\n                     */\n                    pause: function pause(proxy) {\n                        var i = observables.length;\n                        var foundMatch = false;\n                        while (i--) {\n                            if (observables[i].parentProxy === proxy) {\n                                observables[i].paused = true;\n                                foundMatch = true;\n                                break;\n                            }\n                        }\n                        if (foundMatch === false) throw new Error('DOZ could not pause observable -- matching proxy not found.');\n                    },\n\n                    /**\r\n                     * Resume\r\n                     * @param proxy {Proxy} the ES6 Proxy returned by the create() method\r\n                     */\n                    resume: function resume(proxy) {\n                        var i = observables.length;\n                        var foundMatch = false;\n                        while (i--) {\n                            if (observables[i].parentProxy === proxy) {\n                                observables[i].paused = false;\n                                foundMatch = true;\n                                break;\n                            }\n                        }\n                        if (foundMatch === false) throw new Error('DOZ could not resume observable -- matching proxy not found.');\n                    },\n\n                    /**\r\n                     * Remove\r\n                     * @description this method will remove the observable and proxy thereby preventing any further callback observers for changes occuring to the target object.\r\n                     * @param proxy {Proxy} the ES6 Proxy returned by the create() method\r\n                     */\n                    remove: function remove(proxy) {\n\n                        var matchedObservable = null;\n                        var foundMatch = false;\n\n                        var c = observables.length;\n                        while (c--) {\n                            if (observables[c].parentProxy === proxy) {\n                                matchedObservable = observables[c];\n                                foundMatch = true;\n                                break;\n                            }\n                        }\n                        var a = targetsProxy.length;\n                        while (a--) {\n                            var b = targetsProxy[a].length;\n                            while (b--) {\n                                if (targetsProxy[a][b].observable === matchedObservable) {\n                                    targetsProxy[a].splice(b, 1);\n                                    if (targetsProxy[a].length === 0) {\n                                        targetsProxy.splice(a, 1);\n                                        targets.splice(a, 1);\n                                    }\n                                }\n                            }\n                        }\n                        if (foundMatch === true) {\n                            observables.splice(c, 1);\n                        }\n                    },\n\n                    /**\r\n                     * beforeChange\r\n                     * @description This method accepts a function will be invoked before changes.\r\n                     * @param proxy {Proxy} the ES6 Proxy returned by the create() method.\r\n                     * @param callback {Function} will be invoked before every change is made to the proxy, if it returns false no changes will be made.\r\n                     */\n                    beforeChange: function beforeChange(proxy, callback) {\n                        if (typeof callback !== 'function') throw new Error('Callback function is required');\n\n                        var i = observables.length;\n                        var foundMatch = false;\n                        while (i--) {\n                            if (observables[i].parentProxy === proxy) {\n                                observables[i].beforeChange = callback;\n                                foundMatch = true;\n                                break;\n                            }\n                        }\n                        if (foundMatch === false) throw new Error('DOZ -- matching proxy not found.');\n                    },\n\n                    /**\r\n                     * beginRender\r\n                     * @description This method set renderMode to true so the param in get is sanitized.\r\n                     * @param proxy {Proxy} the ES6 Proxy returned by the create() method.\r\n                     */\n                    beginRender: function beginRender(proxy) {\n                        var i = observables.length;\n                        var foundMatch = false;\n                        while (i--) {\n                            if (observables[i].parentProxy === proxy) {\n                                observables[i].renderMode = true;\n                                foundMatch = true;\n                                break;\n                            }\n                        }\n                        if (foundMatch === false) throw new Error('DOZ -- matching proxy not found.');\n                    },\n\n                    /**\r\n                     * endRender\r\n                     * @description This method set renderMode to false.\r\n                     * @param proxy {Proxy} the ES6 Proxy returned by the create() method.\r\n                     */\n                    endRender: function endRender(proxy) {\n                        var i = observables.length;\n                        var foundMatch = false;\n                        while (i--) {\n                            if (observables[i].parentProxy === proxy) {\n                                observables[i].renderMode = false;\n                                foundMatch = true;\n                                break;\n                            }\n                        }\n                        if (foundMatch === false) throw new Error('DOZ -- matching proxy not found.');\n                    }\n                };\n            }();\n\n            module.exports = ObservableSlim;\n\n            /***/\n        },\n        /* 6 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var deprecate = __webpack_require__(17);\n\n            function callBeforeCreate(context) {\n                if (typeof context.onBeforeCreate === 'function') {\n                    return context.onBeforeCreate.call(context);\n                }\n            }\n\n            function callCreate(context) {\n                if (typeof context.onCreate === 'function') {\n                    context.onCreate.call(context);\n                }\n            }\n\n            function callRender(context) {\n                if (typeof context.onRender === 'function') {\n                    deprecate.once('onRender is deprecated since v. 1.0.0, use onMount instead');\n                    context.onRender.call(context);\n                }\n            }\n\n            function callBeforeMount(context) {\n                if (typeof context.onBeforeMount === 'function') {\n                    return context.onBeforeMount.call(context);\n                }\n            }\n\n            function callMount(context) {\n                if (typeof context.onMount === 'function') {\n                    context.onMount.call(context);\n                }\n            }\n\n            function callBeforeUpdate(context, changes) {\n                if (typeof context.onBeforeUpdate === 'function') {\n                    return context.onBeforeUpdate.call(context, changes);\n                }\n            }\n\n            function callUpdate(context, changes) {\n                if (typeof context.onUpdate === 'function') {\n                    context.onUpdate.call(context, changes);\n                }\n            }\n\n            function callBeforeUnmount(context) {\n                if (typeof context.onBeforeUnmount === 'function') {\n                    return context.onBeforeUnmount.call(context);\n                }\n            }\n\n            function callUnmount(context) {\n                if (typeof context.onUnmount === 'function') {\n                    context.onUnmount.call(context);\n                }\n            }\n\n            function callBeforeDestroy(context) {\n                if (typeof context.onBeforeDestroy === 'function') {\n                    return context.onBeforeDestroy.call(context);\n                }\n            }\n\n            function callDestroy(context) {\n                if (typeof context.onDestroy === 'function') {\n                    context.onDestroy.call(context);\n                    context = null;\n                }\n            }\n\n            module.exports = {\n                callBeforeCreate: callBeforeCreate,\n                callCreate: callCreate,\n                callRender: callRender,\n                callBeforeMount: callBeforeMount,\n                callMount: callMount,\n                callBeforeUpdate: callBeforeUpdate,\n                callUpdate: callUpdate,\n                callBeforeUnmount: callBeforeUnmount,\n                callUnmount: callUnmount,\n                callBeforeDestroy: callBeforeDestroy,\n                callDestroy: callDestroy\n            };\n\n            /***/\n        },\n        /* 7 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function delay(cb) {\n                if (window.requestAnimationFrame !== undefined) return window.requestAnimationFrame(cb);else return window.setTimeout(cb);\n            }\n\n            module.exports = delay;\n\n            /***/\n        },\n        /* 8 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var castStringTo = __webpack_require__(9);\n            var dashToCamel = __webpack_require__(10);\n\n            var _require = __webpack_require__(0),\n                REGEX = _require.REGEX,\n                ATTR = _require.ATTR;\n\n            function serializeProps(node) {\n                var props = {};\n                if (node.attributes) {\n                    var attributes = Array.from(node.attributes);\n                    for (var j = attributes.length - 1; j >= 0; --j) {\n                        var attr = attributes[j];\n                        var isComponentListener = attr.name.match(REGEX.IS_COMPONENT_LISTENER);\n                        if (isComponentListener) {\n                            if (props[ATTR.LISTENER] === undefined) props[ATTR.LISTENER] = {};\n                            props[ATTR.LISTENER][isComponentListener[1]] = attr.nodeValue;\n                            delete props[attr.name];\n                        } else {\n                            var value = attr.nodeValue;\n                            if (REGEX.IS_STRING_QUOTED.test(value)) value = attr.nodeValue.replace(/\"/g, '&quot;');\n                            props[REGEX.IS_CUSTOM_TAG.test(node.nodeName) ? dashToCamel(attr.name) : attr.name] = attr.name === ATTR.FORCE_UPDATE ? true : castStringTo(value);\n                        }\n                    }\n                }\n                return props;\n            }\n\n            function transform(node) {\n\n                var root = {};\n\n                function walking(node, parent) {\n                    while (node) {\n                        var obj = void 0;\n\n                        if (node.nodeType === 3) {\n                            obj = node.nodeValue;\n                        } else {\n                            obj = {};\n                            obj.type = node.nodeName; //.toLowerCase();\n                            obj.children = [];\n                            obj.props = serializeProps(node);\n                            obj.isSVG = typeof node.ownerSVGElement !== 'undefined';\n                            //console.dir(node);\n                        }\n\n                        if (!Object.keys(root).length) root = obj;\n\n                        if (parent && parent.children) {\n                            parent.children.push(obj);\n                        }\n\n                        if (node.hasChildNodes()) {\n                            walking(node.firstChild, obj);\n                        }\n\n                        node = node.nextSibling;\n                    }\n                }\n\n                walking(node, root);\n\n                return root;\n            }\n\n            module.exports = {\n                transform: transform,\n                serializeProps: serializeProps\n            };\n\n            /***/\n        },\n        /* 9 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function castStringTo(obj) {\n\n                if (typeof obj !== 'string') {\n                    return obj;\n                }\n\n                switch (obj) {\n                    case 'undefined':\n                        return undefined;\n                    case 'null':\n                        return null;\n                    case 'NaN':\n                        return NaN;\n                    case 'Infinity':\n                        return Infinity;\n                    case 'true':\n                        return true;\n                    case 'false':\n                        return false;\n                    case '0':\n                        return 0; //obj;\n                    default:\n                        try {\n                            return JSON.parse(obj);\n                        } catch (e) {}\n                        break;\n                }\n\n                var num = parseFloat(obj);\n                if (!isNaN(num) && isFinite(obj)) {\n                    if (obj.toLowerCase().indexOf('0x') === 0) {\n                        return parseInt(obj, 16);\n                    }\n                    return num;\n                }\n\n                return obj;\n            }\n\n            module.exports = castStringTo;\n\n            /***/\n        },\n        /* 10 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function dashToCamel(s) {\n                return s.replace(/(-\\w)/g, function (m) {\n                    return m[1].toUpperCase();\n                });\n            }\n\n            module.exports = dashToCamel;\n\n            /***/\n        },\n        /* 11 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var element = __webpack_require__(18);\n\n            module.exports = {\n                updateElement: element.update\n            };\n\n            /***/\n        },\n        /* 12 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            module.exports = __webpack_require__(13);\n\n            /***/\n        },\n        /* 13 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            module.exports = __webpack_require__(14);\n            module.exports.component = __webpack_require__(3).component;\n            module.exports.collection = __webpack_require__(1);\n            module.exports.update = __webpack_require__(11).updateElement;\n            module.exports.transform = __webpack_require__(8).transform;\n            module.exports.html = __webpack_require__(4);\n            module.exports.version = '1.1.1';\n\n            /***/\n        },\n        /* 14 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            } : function (obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            };\n\n            var _createClass = function () {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }return function (Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n                };\n            }();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n\n            var extend = __webpack_require__(2);\n            var bind = __webpack_require__(15);\n            var component = __webpack_require__(3);\n\n            var _require = __webpack_require__(0),\n                TAG = _require.TAG,\n                REGEX = _require.REGEX;\n\n            var Doz = function () {\n                function Doz() {\n                    var _this = this;\n\n                    var cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n                    _classCallCheck(this, Doz);\n\n                    var template = '<' + TAG.APP + '></' + TAG.APP + '>';\n\n                    if (REGEX.IS_ID_SELECTOR.test(cfg.root)) {\n                        cfg.root = document.getElementById(cfg.root.substring(1));\n                    }\n\n                    if (REGEX.IS_ID_SELECTOR.test(cfg.template)) {\n                        cfg.template = document.getElementById(cfg.template.substring(1));\n                        cfg.template = cfg.template.innerHTML;\n                    }\n\n                    if (!(cfg.root instanceof HTMLElement)) {\n                        throw new TypeError('root must be an HTMLElement or an valid ID selector like #example-root');\n                    }\n\n                    if (!(cfg.template instanceof HTMLElement || typeof cfg.template === 'string' || typeof cfg.template === 'function')) {\n                        throw new TypeError('template must be a string or an HTMLElement or a function or an valid ID selector like #example-template');\n                    }\n\n                    this.cfg = extend(cfg, {\n                        components: [],\n                        actions: {}\n                    });\n\n                    Object.defineProperties(this, {\n                        _components: {\n                            value: {},\n                            writable: true\n                        },\n                        _usedComponents: {\n                            value: {},\n                            writable: true\n                        },\n                        _stores: {\n                            value: {},\n                            writable: true\n                        },\n                        _cache: {\n                            value: new Map()\n                        },\n                        _ids: {\n                            value: {},\n                            writable: true\n                        },\n                        _onAppReadyCB: {\n                            value: [],\n                            writable: true\n                        },\n                        _callAppReady: {\n                            value: function value() {\n                                this._onAppReadyCB.forEach(function (cb) {\n                                    if (typeof cb === 'function' && cb._instance) {\n                                        cb.call(cb._instance);\n                                    }\n                                });\n\n                                this._onAppReadyCB = [];\n                            }\n                        },\n                        action: {\n                            value: bind(this.cfg.actions, this),\n                            enumerable: true\n                        },\n                        mount: {\n                            value: function value(_template, root) {\n                                var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._tree;\n\n                                if (typeof root === 'string') {\n                                    root = document.querySelector(root);\n                                }\n\n                                root = root || parent._rootElement;\n\n                                if (!(root instanceof HTMLElement)) {\n                                    throw new TypeError('root must be an HTMLElement or an valid selector like #example-root');\n                                }\n\n                                var autoCmp = {\n                                    tag: TAG.MOUNT,\n                                    cfg: {\n                                        props: {},\n                                        template: function template() {\n                                            return '<' + TAG.ROOT + '>' + _template + '</' + TAG.ROOT + '>';\n                                        }\n                                    }\n                                };\n\n                                return component.getInstances({\n                                    root: root,\n                                    template: '<' + TAG.MOUNT + '></' + TAG.MOUNT + '>',\n                                    app: this,\n                                    parentCmp: parent,\n                                    //isStatic: false,\n                                    autoCmp: autoCmp,\n                                    mount: true\n                                });\n                            },\n                            enumerable: true\n                        }\n                    });\n\n                    if (Array.isArray(this.cfg.components)) {\n                        this.cfg.components.forEach(function (cmp) {\n                            if ((typeof cmp === 'undefined' ? 'undefined' : _typeof(cmp)) === 'object' && typeof cmp.tag === 'string' && _typeof(cmp.cfg) === 'object') {\n                                _this._components[cmp.tag] = cmp;\n                            }\n                        });\n                    } else if (_typeof(this.cfg.components) === 'object') {\n                        //this._components = Object.assign({}, this.cfg.components);\n                        Object.keys(this.cfg.components).forEach(function (objName) {\n                            _this._components[objName] = {\n                                tag: objName,\n                                cfg: _this.cfg.components[objName]\n                            };\n                        });\n                    }\n\n                    this._components[TAG.APP] = {\n                        tag: TAG.APP,\n                        cfg: {\n                            props: cfg.props || {},\n                            template: function template() {\n                                return typeof cfg.template === 'function' ? cfg.template() : cfg.template;\n                            }\n                        }\n                    };\n\n                    this._tree = component.getInstances({ root: this.cfg.root, template: template, app: this }) || [];\n                    this._callAppReady();\n                }\n\n                _createClass(Doz, [{\n                    key: 'getComponent',\n                    value: function getComponent(alias) {\n                        return this._tree ? this._tree.children[alias] : undefined;\n                    }\n                }, {\n                    key: 'getComponentById',\n                    value: function getComponentById(id) {\n                        return this._ids[id];\n                    }\n                }, {\n                    key: 'getStore',\n                    value: function getStore(store) {\n                        return this._stores[store];\n                    }\n                }]);\n\n                return Doz;\n            }();\n\n            module.exports = Doz;\n\n            /***/\n        },\n        /* 15 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            } : function (obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            };\n\n            function bind(obj, context) {\n                if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n                    throw new TypeError('expected an object');\n                }\n\n                var target = Object.assign({}, obj);\n\n                var keys = Object.keys(obj);\n\n                for (var i = keys.length - 1; i >= 0; --i) {\n                    var item = target[keys[i]];\n                    if (typeof item === 'function') {\n                        target[keys[i]] = item.bind(context);\n                    } else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n                        target[keys[i]] = bind(item, context);\n                    }\n                }\n\n                return target;\n            }\n\n            module.exports = bind;\n\n            /***/\n        },\n        /* 16 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                        arr2[i] = arr[i];\n                    }return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n\n            var proxy = __webpack_require__(5);\n            var events = __webpack_require__(6);\n            var delay = __webpack_require__(7);\n\n            function updateBound(instance, changes) {\n                changes.forEach(function (item) {\n                    if (instance._boundElements.hasOwnProperty(item.property)) {\n                        instance._boundElements[item.property].forEach(function (element) {\n                            if (element.type === 'checkbox') {\n                                if (!element.defaultValue) element.checked = item.newValue;else if (Array.isArray(item.newValue)) {\n                                    var inputs = document.querySelectorAll('input[name=' + element.name + '][type=checkbox]');\n                                    [].concat(_toConsumableArray(inputs)).forEach(function (input) {\n                                        return input.checked = item.newValue.includes(input.value);\n                                    });\n                                }\n                            } else if (element.type === 'radio') {\n                                element.checked = element.value === item.newValue;\n                            } else if (element.type === 'select-multiple' && Array.isArray(item.newValue)) {\n                                [].concat(_toConsumableArray(element.options)).forEach(function (option) {\n                                    return option.selected = item.newValue.includes(option.value);\n                                });\n                            } else {\n                                element.value = item.newValue;\n                            }\n                        });\n                    }\n                });\n            }\n\n            function create(instance, props) {\n                instance.props = proxy.create(props, true, function (changes) {\n                    instance.render();\n                    updateBound(instance, changes);\n                    if (instance._isCreated) {\n                        delay(function () {\n                            //updateChildren(instance, changes);\n                            events.callUpdate(instance, changes);\n                        });\n                    }\n                });\n\n                proxy.beforeChange(instance.props, function (changes) {\n                    var res = events.callBeforeUpdate(instance, changes);\n                    if (res === false) return false;\n                });\n            }\n\n            module.exports = {\n                create: create\n            };\n\n            /***/\n        },\n        /* 17 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _list = [];\n\n            /**\r\n             * Simple deprecate\r\n             * @param prop {*}\r\n             * @param msg {string}\r\n             * @returns {boolean}\r\n             */\n            var deprecate = function deprecate(prop, msg) {\n                if (typeof prop !== 'undefined') {\n                    msg = msg || prop;\n\n                    if (!_list.includes(msg)) _list.push(msg);\n\n                    console.warn('[' + deprecate.title + ']', msg);\n                    return true;\n                }\n                return false;\n            };\n\n            deprecate.title = 'DeprecationWarning';\n\n            /**\r\n             * Calls only once same deprecation\r\n             * @param args\r\n             * @returns {boolean}\r\n             */\n            var once = function once() {\n                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                }\n\n                if (_list.includes(args[1] || args[0])) return false;\n                return deprecate.apply(undefined, args);\n            };\n\n            module.exports = deprecate;\n            module.exports.once = once;\n            module.exports._list = _list;\n\n            /***/\n        },\n        /* 18 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            } : function (obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            };\n\n            var _require = __webpack_require__(19),\n                attach = _require.attach,\n                updateAttributes = _require.updateAttributes;\n\n            var deadChildren = [];\n\n            var _require2 = __webpack_require__(0),\n                INSTANCE = _require2.INSTANCE,\n                TAG = _require2.TAG,\n                NS = _require2.NS,\n                CMP_INSTANCE = _require2.CMP_INSTANCE;\n\n            function isChanged(nodeA, nodeB) {\n                return (typeof nodeA === 'undefined' ? 'undefined' : _typeof(nodeA)) !== (typeof nodeB === 'undefined' ? 'undefined' : _typeof(nodeB)) || typeof nodeA === 'string' && nodeA !== nodeB || nodeA.type !== nodeB.type || nodeA.props && nodeA.props.forceupdate;\n            }\n\n            function create(node, cmp, initial) {\n                if (typeof node === 'undefined') return;\n\n                if (typeof node === 'string') {\n                    return document.createTextNode(node);\n                }\n\n                if (node.type[0] === '#') {\n                    node.type = TAG.EMPTY;\n                }\n\n                var $el = node.isSVG ? document.createElementNS(NS.SVG, node.type) : document.createElement(node.type);\n\n                attach($el, node.props, cmp);\n\n                node.children.map(function (item) {\n                    return create(item, cmp, initial);\n                }).forEach($el.appendChild.bind($el));\n\n                if (node.type.indexOf('-') !== -1 && !initial) {\n                    cmp._processing.push({ node: $el, action: 'create' });\n                }\n\n                return $el;\n            }\n\n            function update($parent, newNode, oldNode) {\n                var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n                var cmp = arguments[4];\n                var initial = arguments[5];\n\n                if (!oldNode) {\n                    var rootElement = create(newNode, cmp, initial);\n                    $parent.appendChild(rootElement);\n                    return rootElement;\n                } else if (!newNode) {\n                    if ($parent.childNodes[index]) {\n                        deadChildren.push($parent.childNodes[index]);\n                    }\n                } else if (isChanged(newNode, oldNode)) {\n                    var newElement = create(newNode, cmp, initial);\n                    var oldElement = $parent.childNodes[index];\n\n                    //Re-assign CMP INSTANCE to new element\n                    if (oldElement[CMP_INSTANCE]) {\n                        newElement[CMP_INSTANCE] = oldElement[CMP_INSTANCE];\n                        newElement[CMP_INSTANCE]._rootElement = newElement;\n                    }\n\n                    $parent.replaceChild(newElement, oldElement);\n                    return newElement;\n                } else if (newNode.type) {\n                    var updated = updateAttributes($parent.childNodes[index], newNode.props, oldNode.props, cmp);\n\n                    if ($parent.childNodes[index]) {\n                        var dynInstance = $parent.childNodes[index][INSTANCE];\n                        if (dynInstance && updated.length) {\n                            updated.forEach(function (props) {\n                                Object.keys(props).forEach(function (name) {\n                                    dynInstance.props[name] = props[name];\n                                });\n                            });\n\n                            return;\n                        }\n                    }\n\n                    var newLength = newNode.children.length;\n                    var oldLength = oldNode.children.length;\n\n                    for (var i = 0; i < newLength || i < oldLength; i++) {\n                        update($parent.childNodes[index], newNode.children[i], oldNode.children[i], i, cmp, initial);\n                    }\n\n                    clearDead();\n                }\n            }\n\n            function clearDead() {\n                var dl = deadChildren.length;\n\n                while (dl--) {\n                    deadChildren[dl].parentNode.removeChild(deadChildren[dl]);\n                    deadChildren.splice(dl, 1);\n                }\n            }\n\n            module.exports = {\n                create: create,\n                update: update\n            };\n\n            /***/\n        },\n        /* 19 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            } : function (obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n            };\n\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                        arr2[i] = arr[i];\n                    }return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n\n            var _require = __webpack_require__(0),\n                REGEX = _require.REGEX,\n                ATTR = _require.ATTR,\n                CMP_INSTANCE = _require.CMP_INSTANCE;\n\n            var castStringTo = __webpack_require__(9);\n            var dashToCamel = __webpack_require__(10);\n            var camelToDash = __webpack_require__(20);\n            var objectPath = __webpack_require__(21);\n            var delay = __webpack_require__(7);\n\n            function isEventAttribute(name) {\n                return REGEX.IS_LISTENER.test(name);\n            }\n\n            function isBindAttribute(name) {\n                return name === ATTR.BIND;\n            }\n\n            function isRefAttribute(name) {\n                return name === ATTR.REF;\n            }\n\n            function canBind($target) {\n                return ['INPUT', 'TEXTAREA', 'SELECT'].indexOf($target.nodeName) !== -1;\n            }\n\n            function setAttribute($target, name, value, cmp) {\n                if (REGEX.IS_CUSTOM_TAG.test($target.nodeName)) name = camelToDash(name);\n                if (isCustomAttribute(name)) {} else if (typeof value === 'boolean') {\n                    setBooleanAttribute($target, name, value);\n                } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n                    try {\n                        $target.setAttribute(name, JSON.stringify(value));\n                    } catch (e) {}\n                } else {\n                    $target.setAttribute(name, value);\n                }\n            }\n\n            function removeAttribute($target, name, value) {\n                if (isCustomAttribute(name)) {} else {\n                    $target.removeAttribute(name);\n                }\n            }\n\n            function updateAttribute($target, name, newVal, oldVal, cmp) {\n                if (!newVal /*&& newVal !== false*/) {\n                        removeAttribute($target, name, oldVal, cmp);\n                        updateChildren(cmp, name, newVal, $target);\n                    } else if (!oldVal || newVal !== oldVal) {\n                    setAttribute($target, name, newVal, cmp);\n                    updateChildren(cmp, name, newVal, $target);\n                }\n            }\n\n            function updateChildren(cmp, name, value, $target) {\n                if (cmp && cmp.updateChildrenProps) {\n                    name = dashToCamel(name);\n                    var firstChild = $target.firstChild;\n                    if (firstChild && firstChild[CMP_INSTANCE] && firstChild[CMP_INSTANCE]._publicProps.hasOwnProperty(name)) firstChild[CMP_INSTANCE].props[name] = value;\n                }\n            }\n\n            function updateAttributes($target, newProps) {\n                var oldProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var cmp = arguments[3];\n\n                var props = Object.assign({}, newProps, oldProps);\n                var updated = [];\n                Object.keys(props).forEach(function (name) {\n                    updateAttribute($target, name, newProps[name], oldProps[name], cmp);\n                    if (newProps[name] !== oldProps[name]) {\n                        var obj = {};\n                        obj[name] = newProps[name];\n                        updated.push(obj);\n                    }\n                });\n\n                return updated;\n            }\n\n            function isCustomAttribute(name) {\n                return isEventAttribute(name) || isBindAttribute(name) || isRefAttribute(name) || name === ATTR.FORCE_UPDATE;\n            }\n\n            function setBooleanAttribute($target, name, value) {\n                $target.setAttribute(name, value);\n                $target[name] = value;\n            }\n\n            function extractEventName(name) {\n                return name.slice(2).toLowerCase();\n            }\n\n            function trimQuotes(str) {\n                return str.replace(REGEX.TRIM_QUOTES, '$1');\n            }\n\n            function addEventListener($target, name, value, cmp) {\n\n                if (!isEventAttribute(name)) return;\n\n                var match = value.match(REGEX.GET_LISTENER);\n\n                if (match) {\n                    var args = null;\n                    var handler = match[1];\n                    var stringArgs = match[2];\n                    if (stringArgs) {\n                        args = stringArgs.split(',').map(function (item) {\n                            item = item.trim();\n                            return item === 'this' ? cmp : castStringTo(trimQuotes(item));\n                        });\n                    }\n\n                    var isParentMethod = handler.match(REGEX.IS_PARENT_METHOD);\n\n                    if (isParentMethod) {\n                        handler = isParentMethod[1];\n                        cmp = cmp.parent;\n                    }\n\n                    var method = objectPath(handler, cmp);\n\n                    if (method !== undefined) {\n                        value = args ? method.bind.apply(method, [cmp].concat(_toConsumableArray(args))) : method.bind(cmp);\n                    }\n                }\n\n                if (typeof value === 'function') $target.addEventListener(extractEventName(name), value);\n            }\n\n            function setBind($target, name, value, cmp) {\n                if (!isBindAttribute(name) || !canBind($target)) return;\n                if (typeof cmp.props[value] !== 'undefined') {\n\n                    var events = ['compositionstart', 'compositionend', 'input', 'change'];\n\n                    events.forEach(function (event) {\n                        $target.addEventListener(event, function (e) {\n                            var _value = void 0;\n                            if (this.type === 'checkbox') {\n                                if (!this.defaultValue) cmp.props[value] = this.checked;else {\n                                    var inputs = document.querySelectorAll('input[name=' + this.name + '][type=checkbox]:checked');\n                                    _value = [].concat(_toConsumableArray(inputs)).map(function (input) {\n                                        return input.value;\n                                    });\n                                    cmp.props[value] = _value;\n                                }\n                            } else {\n                                _value = this.value;\n                                if (this.multiple) {\n                                    _value = [].concat(_toConsumableArray(this.options)).filter(function (option) {\n                                        return option.selected;\n                                    }).map(function (option) {\n                                        return option.value;\n                                    });\n                                }\n                                cmp.props[value] = _value;\n                            }\n                        });\n                    });\n\n                    if (cmp._boundElements.hasOwnProperty(value)) {\n                        cmp._boundElements[value].push($target);\n                    } else {\n                        cmp._boundElements[value] = [$target];\n                    }\n\n                    return true;\n                }\n            }\n\n            function setRef($target, name, value, cmp) {\n                if (!isRefAttribute(name)) return;\n                cmp.ref[value] = $target;\n            }\n\n            function attach($target, props, cmp) {\n                var bindValue = void 0;\n\n                Object.keys(props).forEach(function (name) {\n                    setAttribute($target, name, props[name], cmp);\n                    addEventListener($target, name, props[name], cmp);\n                    if (setBind($target, name, props[name], cmp)) {\n                        bindValue = cmp.props[props[name]];\n                    }\n                    setRef($target, name, props[name], cmp);\n                });\n\n                for (var i in $target.dataset) {\n                    if ($target.dataset.hasOwnProperty(i) && REGEX.IS_LISTENER.test(i)) {\n                        addEventListener($target, i, $target.dataset[i], cmp);\n                    }\n                }\n\n                if (typeof bindValue !== 'undefined') {\n                    delay(function () {\n                        var inputs = void 0;\n                        if ($target.type === 'radio') {\n                            inputs = document.querySelectorAll('input[name=' + $target.name + '][type=radio]');\n                            inputs.forEach(function (input) {\n                                return input.checked = bindValue === input.value;\n                            });\n                        } else if ($target.type === 'checkbox') {\n                            if ((typeof bindValue === 'undefined' ? 'undefined' : _typeof(bindValue)) === 'object') {\n                                inputs = document.querySelectorAll('input[name=' + $target.name + '][type=checkbox]');\n                                inputs.forEach(function (input) {\n                                    return input.checked = Array.from(bindValue).includes(input.value);\n                                });\n                            } else $target.checked = bindValue;\n                        } else {\n                            $target.value = bindValue;\n                        }\n                    });\n                }\n            }\n\n            module.exports = {\n                attach: attach,\n                updateAttributes: updateAttributes\n            };\n\n            /***/\n        },\n        /* 20 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function camelToDash(s) {\n                return s.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();\n            }\n\n            module.exports = camelToDash;\n\n            /***/\n        },\n        /* 21 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function getByPath(path, obj) {\n                return path.split('.').reduce(function (res, prop) {\n                    return res ? res[prop] : undefined;\n                }, obj);\n            }\n\n            function getLast(path, obj) {\n                if (path.indexOf('.') !== -1) {\n                    path = path.split('.');\n                    path.pop();\n                    path = path.join('.');\n                }\n                return getByPath(path, obj);\n            }\n\n            module.exports = getByPath;\n            module.exports.getLast = getLast;\n\n            /***/\n        },\n        /* 22 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function create(instance) {\n\n                if (typeof instance.store === 'string') {\n                    if (instance.app._stores[instance.store] !== undefined) {\n                        throw new Error('Store already defined: ' + instance.store);\n                    }\n                    instance.app._stores[instance.store] = instance.props;\n                }\n            }\n\n            module.exports = {\n                create: create\n            };\n\n            /***/\n        },\n        /* 23 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            function create(instance) {\n\n                if (typeof instance.id === 'string') {\n                    if (instance.app._ids[instance.id] !== undefined) {\n                        throw new Error('ID already defined: ' + instance.id);\n                    }\n                    instance.app._ids[instance.id] = instance;\n                }\n            }\n\n            module.exports = {\n                create: create\n            };\n\n            /***/\n        },\n        /* 24 */\n        /***/function (module, exports, __webpack_require__) {\n\n            \"use strict\";\n\n            var _require = __webpack_require__(0),\n                ATTR = _require.ATTR;\n\n            function extract(props) {\n\n                var dProps = {};\n\n                if (props[ATTR.ALIAS] !== undefined) {\n                    dProps['alias'] = props[ATTR.ALIAS];\n                    delete props[ATTR.ALIAS];\n                }\n\n                if (props[ATTR.STORE] !== undefined) {\n                    dProps['store'] = props[ATTR.STORE];\n                    delete props[ATTR.STORE];\n                }\n\n                if (props[ATTR.LISTENER] !== undefined) {\n                    dProps['callback'] = props[ATTR.LISTENER];\n                    delete props[ATTR.LISTENER];\n                }\n\n                if (props[ATTR.ID] !== undefined) {\n                    dProps['id'] = props[ATTR.ID];\n                    delete props[ATTR.ID];\n                }\n\n                return dProps;\n            }\n\n            module.exports = {\n                extract: extract\n            };\n\n            /***/\n        }]\n        /******/)\n    );\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://DozSearchfield/./node_modules/doz/dist/doz.js?")},"./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve "head" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }\n                // }\n                if (typeof target === \'function\') {\n                        return target();\n                }\n                if (typeof memo[target] === "undefined") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === "object" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + " " + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error("[Style Loader]\\n\\n Invalid value for parameter \'insertAt\' (\'options.insertAt\') found.\\n Must be \'top\', \'bottom\', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack://DozSearchfield/./node_modules/style-loader/lib/addStyles.js?')},"./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n\t// get current location\n\tvar location = typeof window !== "undefined" && window.location;\n\n\tif (!location) {\n\t\tthrow new Error("fixUrls requires window.location");\n\t}\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t\treturn css;\n\t}\n\n\tvar baseUrl = location.protocol + "//" + location.host;\n\tvar currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n This regular expression is just a way to recursively match brackets within\n a string.\n \t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n    (  = Start a capturing group\n      (?:  = Start a non-capturing group\n          [^)(]  = Match anything that isn\'t a parentheses\n          |  = OR\n          \\(  = Match a start parentheses\n              (?:  = Start another non-capturing groups\n                  [^)(]+  = Match anything that isn\'t a parentheses\n                  |  = OR\n                  \\(  = Match a start parentheses\n                      [^)(]*  = Match anything that isn\'t a parentheses\n                  \\)  = Match a end parentheses\n              )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n  \\)  = Match a close parens\n \t /gi  = Get all matches, not the first.  Be case insensitive.\n  */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t}).replace(/^\'(.*)\'$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t});\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t\treturn fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t\t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceURL=webpack://DozSearchfield/./node_modules/style-loader/lib/urls.js?')},"./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n//# sourceURL=webpack://DozSearchfield/(webpack)/buildin/module.js?')}})}); 